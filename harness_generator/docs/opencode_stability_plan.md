# OpenCode 产出稳定性提升计划（Sherpa）

本文面向 Sherpa 现有工作流（plan → synthesize → build → run → fix），目标是降低 OpenCode 输出抖动、减少无效重试、提高批量任务可复现性。

## 0. 当前基础（已具备）

仓库已经有一些稳定性基础能力：

- OpenCode 运行封装与重试、超时控制（`codex_helper.py`）。
- OpenCode 运行默认禁止执行构建/运行类命令（`SHERPA_OPENCODE_NO_EXEC=1`）。
- 工作流侧存在 build 阶段自动重试与清理重试。
- 统一日志分类（含 `cat.opencode.log`）便于回溯。

以下计划是在这些基础上做增强。

---

## 1) Prompt 与输入收敛（优先级 P0）

### 目标
降低“同样上下文、不同轮次输出差异”。

### 行动

1. **Prompt 模板标准化**
   - 将 plan/synthesize/fix 提示词统一为“目标、输入、硬约束、输出 schema、禁止项”五段。
   - 每个模板固定要求“仅修改指定文件”与“输出必须可机读（json/markdown 标头）”。

2. **上下文裁剪与白名单化**
   - 给 OpenCode 输入建立固定顺序：`目标文件 -> 失败日志摘要 -> 最小必要源码片段`。
   - 统一日志摘要长度（如 120~200 行），避免上下文波动。

3. **失败 hint 去噪**
   - 对 build/run 错误做规则化摘要（按编译错误、链接错误、运行时错误分桶），再传给 fix。

### 验收指标
- 同一仓库重复执行 3 次，`fuzz/targets.json` 差异率下降。
- fix_build 首轮成功率提升（基线 +10% 以上）。

---

## 2) 结构化输出与自动校验（优先级 P0）

### 目标
从“自然语言正确”升级到“可校验正确”。

### 行动

1. **Plan 阶段强制 JSON schema 校验**
   - 对 `fuzz/targets.json` 增加严格字段校验（函数名、路径、语言、入口类型）。
   - 校验失败时不进入 synthesize，直接触发“仅修复 schema 错误”的窄提示词重试。

2. **Synthesize 阶段产物清单校验**
   - 校验 `fuzz/build.py`、至少 1 个 harness、corpus 目录是否存在。
   - 新增“静态快速检查”脚本：语法检查 + 文件引用检查。

3. **Fix 阶段分流**
   - 将 fix_build 与 fix_crash 的输入格式统一成结构化对象（error_type, file, line, evidence）。
   - 不再直接透传长日志全文。

### 验收指标
- 因格式问题导致的重试次数下降 30%。
- `Missing fuzz/build.py` 类错误占比持续下降。

---

## 3) 重试策略从“固定次数”升级为“分层退火”（优先级 P1）

### 目标
避免重复用同一策略碰撞同一错误。

### 行动

1. **分层重试**
   - 第 1 次：原 prompt（最小改动）。
   - 第 2 次：追加结构化错误摘要。
   - 第 3 次：切换到“重建关键文件”模板。

2. **失败类型驱动策略**
   - 编译错误：优先修类型/头文件/链接。
   - harness 运行时错误：优先修输入边界与空指针。
   - 工程级错误（依赖缺失）：优先修 build.py 而非 harness。

3. **引入退避时间与抖动**
   - 在并发任务高时增加 retry backoff，降低模型侧瞬时拥塞影响。

### 验收指标
- 平均每个 job 的 OpenCode 调用次数下降。
- 第 2/3 次重试成功率较基线显著提高。

---

## 4) 可复现性治理（优先级 P1）

### 目标
把“偶尔成功”变成“可重复成功”。

### 行动

1. **运行元数据落盘**
   - 每次 OpenCode 调用记录：模型名、prompt 模板版本、输入摘要哈希、重试序号。

2. **结果指纹**
   - 对关键产物（targets.json、build.py、harness）做哈希并记录到 `run_summary.json`。

3. **回放机制**
   - 提供 `scripts/replay_opencode.sh`：用同一输入摘要重放某次失败请求，便于回归。

### 验收指标
- 关键失败 case 能够 1 命令重放。
- “无法复现”问题单比例下降。

---

## 5) 观测与质量看板（优先级 P1）

### 目标
让稳定性问题可量化、可预警。

### 行动

1. **新增指标**
   - `opencode_call_total`
   - `opencode_retry_total`
   - `opencode_schema_fail_total`
   - `opencode_first_pass_success_ratio`

2. **按仓库/语言分桶**
   - C/C++ 与 Java 分开统计，避免互相污染。

3. **周报机制**
   - 输出 Top N 不稳定仓库（重试高、格式错误高、不可复现高）。

---

## 6) 建议落地排期（4 周）

- **Week 1（P0）**：Prompt 统一模板 + targets schema 校验 + synthesize 产物校验。
- **Week 2（P0）**：fix 输入结构化 + 失败分桶摘要器。
- **Week 3（P1）**：分层重试/退避策略 + 元数据与结果指纹。
- **Week 4（P1）**：回放脚本 + 稳定性看板指标 + 基线对比报告。

---

## 7) 风险与回滚

- 风险：校验过严会导致短期失败率上升。
  - 对策：采用“告警模式 → 阻断模式”两阶段开关。
- 风险：重试策略过于复杂导致维护成本上升。
  - 对策：以错误分桶为核心，策略配置化，不在代码里散落 hardcode。

---

## 8) 本计划最小实施集（建议先做）

如果只做 3 件事，优先：

1. `targets.json` 严格 schema 校验 + 定向重试。
2. fix 输入结构化（错误分桶 + 证据片段）。
3. OpenCode 调用元数据与产物哈希落盘。

这三项通常能最快提升“稳定产出率”和“故障可定位性”。
